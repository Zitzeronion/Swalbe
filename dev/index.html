<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Swalbe</title><link rel="canonical" href="https://Ziteronion.github.io/Swalbe.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Swalbe</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Zitzeronion/Swalbe.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Swalbe"><a class="docs-heading-anchor" href="#Swalbe">Swalbe</a><a id="Swalbe-1"></a><a class="docs-heading-anchor-permalink" href="#Swalbe" title="Permalink"></a></h1><ul><li><a href="#Swalbe.SysConst"><code>Swalbe.SysConst</code></a></li><li><a href="#Swalbe.BGKandStream!-NTuple{6,Any}"><code>Swalbe.BGKandStream!</code></a></li><li><a href="#Swalbe.Sys-Tuple{Swalbe.SysConst,String,Bool,Any}"><code>Swalbe.Sys</code></a></li><li><a href="#Swalbe.boxpattern-Tuple{Any,Any}"><code>Swalbe.boxpattern</code></a></li><li><a href="#Swalbe.ellipsepattern-Tuple{Any,Any}"><code>Swalbe.ellipsepattern</code></a></li><li><a href="#Swalbe.equilibrium!-NTuple{6,Any}"><code>Swalbe.equilibrium!</code></a></li><li><a href="#Swalbe.filmpressure!-NTuple{8,Any}"><code>Swalbe.filmpressure!</code></a></li><li><a href="#Swalbe.moments!-NTuple{4,Any}"><code>Swalbe.moments!</code></a></li><li><a href="#Swalbe.power_broad-Tuple{Float64,Int64}"><code>Swalbe.power_broad</code></a></li><li><a href="#Swalbe.randinterface!-Tuple{Any,Any,Any}"><code>Swalbe.randinterface!</code></a></li><li><a href="#Swalbe.run_dropletforced-Tuple{Swalbe.SysConst,String}"><code>Swalbe.run_dropletforced</code></a></li><li><a href="#Swalbe.run_dropletpatterned-Tuple{Swalbe.SysConst,String}"><code>Swalbe.run_dropletpatterned</code></a></li><li><a href="#Swalbe.run_dropletrelax-Tuple{Swalbe.SysConst,String}"><code>Swalbe.run_dropletrelax</code></a></li><li><a href="#Swalbe.run_flat-Tuple{Swalbe.SysConst,String}"><code>Swalbe.run_flat</code></a></li><li><a href="#Swalbe.run_random-Tuple{Swalbe.SysConst,String}"><code>Swalbe.run_random</code></a></li><li><a href="#Swalbe.run_rayleightaylor-Tuple{Swalbe.SysConst,String}"><code>Swalbe.run_rayleightaylor</code></a></li><li><a href="#Swalbe.sinewave1D!-Tuple{Any,Any,Int64,Any,Int64}"><code>Swalbe.sinewave1D!</code></a></li><li><a href="#Swalbe.singledroplet-NTuple{4,Any}"><code>Swalbe.singledroplet</code></a></li><li><a href="#Swalbe.slippage!-NTuple{7,Any}"><code>Swalbe.slippage!</code></a></li><li><a href="#Swalbe.thermal!-NTuple{6,Any}"><code>Swalbe.thermal!</code></a></li><li><a href="#Swalbe.trianglepattern-Tuple{Any,Any}"><code>Swalbe.trianglepattern</code></a></li><li><a href="#Swalbe.viewdists-Tuple{Any}"><code>Swalbe.viewdists</code></a></li><li><a href="#Swalbe.viewneighbors-Tuple{Any}"><code>Swalbe.viewneighbors</code></a></li><li><a href="#Swalbe.∇f!-Tuple{Any,Any,Any}"><code>Swalbe.∇f!</code></a></li><li><a href="#Swalbe.∇²f!-Tuple{Any,Any,Any}"><code>Swalbe.∇²f!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Swalbe.SysConst" href="#Swalbe.SysConst"><code>Swalbe.SysConst</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SysConst{T}</code></pre><p>Struct that contains all run time constants, e.g. lattice size, surface tension <code>γ</code> and so on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.BGKandStream!-NTuple{6,Any}" href="#Swalbe.BGKandStream!-NTuple{6,Any}"><code>Swalbe.BGKandStream!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BGKandStream!(fout, feq, ftemp, Fx, Fy, τ)</code></pre><p>Performs a BGK collision operation with a WFM forcecorrection and a subsequent streaming of the resulting populations.</p><p><strong>Arguments</strong></p><ul><li><code>fout :: Array{&lt;:Number,3}</code>: Streamed distribution after the collision processes</li><li><code>feq :: Array{&lt;:Number,3}</code>: Equilibrium distribution, computed with equilibrium!</li><li><code>ftemp :: Array{&lt;:Number,3}</code>: Temporary distribution from the time step before, only useful if <span>$\tau \neq 1$</span></li><li><code>Fx :: Array{&lt;:Number,2}</code>: Sum of forces acting on the fluid in x-direction</li><li><code>Fy :: Array{&lt;:Number,2}</code>: Sum of forces acting on the fluid in y-direction</li><li><code>τ &lt;: Number</code>: Relaxtion time, if not supplied <span>$\tau = 1$</span> assumed</li></ul><p><strong>Mathematics</strong></p><p>The lattice Boltzmann equation in its discretized format is relatively simple to write down</p><p><span>$f_{\alpha}(\mathbf{x}+\mathbf{e}_{\alpha}\Delta t, t+\Delta t) - f_{\alpha}(\mathbf{x}, t) = -\frac{1}{\tau}(f_{\alpha}(\mathbf{x}, t) - f^{\text{eq}}_{\alpha}(\mathbf{x}, t)) + \Delta t \mathcal{S}_{\alpha},$</span></p><p>where the collision kernel is approximated with a BKG single relaxation time (SRT) </p><p><span>$\Omega_{\alpha} = \frac{1}{\tau}(f_{\alpha}(\mathbf{x}, t) - f^{\text{eq}}_{\alpha}(\mathbf{x}, t),$</span></p><p>and a source term <span>$\mathcal{S}$</span> which is given by</p><p><span>$\mathcal{S}_{\alpha} = \frac{3 w_{\alpha}}{e_{\alpha x}e_{\alpha x}+e_{\alpha y}e_{\alpha y}}\mathbf{e_{\alpha}}\cdot\mathbf{F}_{\alpha} .$</span></p><p>The term <span>$e_{\alpha x}e_{\alpha x}+e_{\alpha y}e_{\alpha y}$</span> is either zero for the zeroth population, 1 for the first four populations or 2 for the remaining ones.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Swalbe

julia&gt; feq = ones(5,5,9); ftemp = zeros(5,5,9); fout = zeros(5,5,9);

julia&gt; feq[1,1,:] .= 2.0 # To check the streaming process 
9-element view(::Array{Float64,3}, 1, 1, :) with eltype Float64:
 2.0
 2.0
 2.0
 2.0
 2.0
 2.0
 2.0
 2.0
 2.0

julia&gt; Swalbe.BGKandStream!(fout, feq, ftemp, zeros(5,5), zeros(5,5))

julia&gt; fout[:,:,6] # The value 2 should have moved one down and one to the right!
5×5 Array{Float64,2}:
 1.0  1.0  1.0  1.0  1.0
 1.0  2.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
</code></pre><p><strong>References</strong></p><ul><li><a href="https://www.ingentaconnect.com/contentone/jmr/jmr/1999/00000057/00000003/art00005#">Salmon</a></li><li><a href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.65.036309">Dellar</a></li><li><a href="https://onlinelibrary.wiley.com/doi/full/10.1002/fld.4726">Peng et al.</a></li></ul><p>See also: <a href="@ref"><code>Swalbe.equilibrium</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.Sys-Tuple{Swalbe.SysConst,String,Bool,Any}" href="#Swalbe.Sys-Tuple{Swalbe.SysConst,String,Bool,Any}"><code>Swalbe.Sys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Sys(sysc, device, exotic)</code></pre><p>Mostly allocations of arrays used to run a simulation, but all within one function :)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.boxpattern-Tuple{Any,Any}" href="#Swalbe.boxpattern-Tuple{Any,Any}"><code>Swalbe.boxpattern</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boxpattern(θ, θ₀; center=(size(θ,1)÷2, size(θ,2)÷2), δₐ=1/36, side=20)</code></pre><p>Defines a quadratic box around a <code>center</code> with side length <code>side</code>.</p><p><strong>Arguments</strong></p><ul><li><code>θ::Array{undef,2}</code>: Contact angle map</li><li><code>θ₀</code>: Default contact angle <code>θ</code></li><li><code>center::Tuple{Int, Int}</code>: center of the box pattern, default value is <code>(size(θ,1)÷2, size(θ,2)÷2)</code></li><li><code>δₐ::Float64</code>: Contact angle contrast with the substrate, default is set to <code>1/36</code> ≈ 5 degrees difference</li><li><code>side::Int</code>: Length of the sides, default is set to <code>20</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Swalbe

julia&gt; θ₀ = 1/9;

julia&gt; pattern, polygon = Swalbe.boxpattern(ones(100,100), θ₀);

julia&gt; polygon # Some cool thing we use to create the posize(θ,2)gones, a LazySet
LazySets.VPolygon{Float64,Array{Float64,1}}([[40.0, 40.0], [60.0, 40.0], [60.0, 60.0], [40.0, 60.0]])

julia&gt; pattern[50,50] == pattern[1,1] # In the center there is a different contact angle!
false
</code></pre><p><strong>References</strong></p><p>Really not much to say here, check out <a href="https://github.com/JuliaReach/LazySets.jl">LazySets.jl</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.ellipsepattern-Tuple{Any,Any}" href="#Swalbe.ellipsepattern-Tuple{Any,Any}"><code>Swalbe.ellipsepattern</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ellipsepattern(θ, θ₀; center=(size(θ,1)÷2, size(θ,2)÷2), δₐ=1/36, a=10, b=5)</code></pre><p>Creates an ellipse shaped contact angle defect with contact angle mismatch <code>δₐ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>θ::Array{undef,2}</code>: Contact angle map</li><li><code>θ₀</code>: Default contact angle <code>θ</code></li><li><code>center::Tuple{Int, Int}</code>: center of the created pattern, default values is <code>center = (size(θ,1)÷2, size(θ,2)÷2)</code></li><li><code>δₐ::Float64</code>: contact angle mismatch between patch and rest of substrate, default is <code>δₐ = 1/36</code> or 5 degrees</li><li><code>a::Int</code>:: semimajor half ax of the ellipse, default value is <code>a=10</code></li><li><code>b::Int</code>:: semiminor half ax of the ellipse, default value is <code>b=5</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Swalbe, Test

julia&gt; θ₀ = 1/9;

julia&gt; θ, P = Swalbe.ellipsepattern(ones(100,100), θ₀); # per default the center is in the middle!

julia&gt; @test θ[1,1] == θ₀
Test Passed

julia&gt; @test θ[50,50] == θ₀ + 1/36 # The default increment, is about 5 degrees.
Test Passed
</code></pre><p><strong>References</strong></p><p>Nothing interesting here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.equilibrium!-NTuple{6,Any}" href="#Swalbe.equilibrium!-NTuple{6,Any}"><code>Swalbe.equilibrium!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Equilibrium!(feq, height,velocityx, velocityy, vsquare, gravity)</code></pre><p>Calculation of the equilibrium distribution <code>feq</code> for the shallow water lattice Boltzmann method.</p><p><strong>Arguments</strong></p><ul><li><code>feq :: Array{&lt;:Number,3}</code>: Equilibrium distribution function, to be calculated</li><li><code>height :: Array{&lt;:Number,2}</code>: The height field <span>$h(\mathbf{x},t)$</span></li><li><code>velocityx :: Array{&lt;:Number,2}</code>: x-component of the macroscopic velocity</li><li><code>velocityy :: Array{&lt;:Number,2}</code>: y-component of the macroscopic velocity</li><li><code>vsquare :: Array{&lt;:Number,2}</code>: Dummy array that is preallocated to be filled with the square of the velocity vector</li><li><code>gravity &lt;: Number</code>: Strength of the gravitational acceleration in lattice units</li></ul><p><strong>Mathematics</strong></p><p>The detailed motivation and derivation can be found in the article of Salmon. Similar to the standard Navier-Stokes approximating lattice Boltzmann methods the equilibrium distribution <code>feq</code> is an expansion to second order in velocity <code>u</code>. If you want it is an slow mode part of the shallow water theory and thus the equilibrium is given as</p><p><span>$f_i^{\text{eq}} = h \bigg(1 - \frac{5}{6}g h - \frac{2}{3}u^2\bigg),\quad i=0 \newline    f_i^{\text{eq}} = w_i h \bigg(g h + 3 \mathbf{c}_i\cdot\mathbf{u} + \frac{9}{2}(\mathbf{c}_i\cdot\mathbf{u})^2) + \frac{3}{2}u^2\bigg),\quad else$</span></p><p>where <span>$g$</span> is the gravitational acceleration (in lattice units) and <span>$w_i, \mathbf{c}_i$</span> are the weights and lattice velocities.</p><p>It has been shown that it is possible to get rid of the gravity driven term in the equilibrium distribution, thus</p><p><span>$f_i^{\text{eq}} = h \bigg(1 - \frac{2}{3}u^2\bigg),\quad i=0 \newline f_i^{\text{eq}} = w_i h \bigg(3 \mathbf{c}_i\cdot\mathbf{u} + \frac{9}{2}(\mathbf{c}_i\cdot\mathbf{u})^2) + \frac{3}{2}u^2\bigg),\quad else$</span></p><p>then of course the topography gradient has to be included as a force term.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Swalbe, Test

julia&gt; feq = zeros(5,5,9); ρ = ones(5,5); ux = fill(0.1,5,5); uy = zeros(5,5);

julia&gt; Swalbe.equilibrium!(feq, ρ, ux, uy, zeros(5,5), 0.1) # Supply dummy u^2 as well.

julia&gt; feq[:,:,1]
5×5 Array{Float64,2}:
 0.91  0.91  0.91  0.91  0.91
 0.91  0.91  0.91  0.91  0.91
 0.91  0.91  0.91  0.91  0.91
 0.91  0.91  0.91  0.91  0.91
 0.91  0.91  0.91  0.91  0.91

julia&gt; Swalbe.equilibrium!(feq, ρ, ux, uy, zeros(5,5)) # Use the dispatch without g.

julia&gt; @test all(feq[:,:,1] .≈ 1 - 2/3 * 0.01)
Test Passed</code></pre><p><strong>References</strong></p><ul><li><a href="https://www.ingentaconnect.com/contentone/jmr/jmr/1999/00000057/00000003/art00005#">Salmon</a></li><li><a href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.65.036309">Dellar</a></li><li><a href="https://onlinelibrary.wiley.com/doi/full/10.1002/fld.4726">Peng et al.</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.filmpressure!-NTuple{8,Any}" href="#Swalbe.filmpressure!-NTuple{8,Any}"><code>Swalbe.filmpressure!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">filmpressure!(pressure, height, γ, θ, n, m, hmin, hcrit)</code></pre><p>Calculation of the capillary pressure which is given by <span>$p = - γ∇²h+ Π(h)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>pressure :: Array{Number,2}</code>: Array that store the result of the compuation</li><li><code>height :: Array{Number,2}</code>: Height field <span>$h(\mathbf{x},t)$</span></li><li><code>γ &lt;: Number</code>: Forcing strenght due to surface tension</li><li><code>θ &lt;: Number</code>: Equilibrium contact angle</li><li><code>n :: Int</code>: Larger power law exponent for <span>$Π(h)$</span></li><li><code>m :: Int</code>: Smaller power law exponent for <span>$Π(h)$</span></li><li><code>hmin &lt;: Number</code>: Parameter of <span>$Π(h)$</span>, in fact <span>$Π(hmin) = 0$</span></li><li><code>hcrit &lt;: Number</code>: Numerical stabilizer for case <span>$h(\mathbf{x},t) \ll hmin$</span></li></ul><p><strong>Mathematics</strong></p><p>The capillary pressure <span>$p_{\text{cap}}$</span> is the centeral angle to match our model with the thin film equation. It consists of two parts, first being the laplace pressure <span>$\nabla^2 h$</span> and second being the derivative of the disjoining pontential <span>$\Pi(h)$</span></p><p><span>$p_{\text{cap}} = -\gamma \nabla^2 h + \Pi(h).$</span></p><p>For the laplacian term we use the same nine point discretization as in <code>Swlabe.∇²f!</code>. <span>$\Pi(h)$</span> on the other hand is given by </p><p><span>$\Pi(h) = \kappa(\theta)f(h),$</span></p><p>where <span>$\kappa(\theta)$</span> is simply a measure for the <strong>Hamaker constant</strong> and given as</p><p><span>$\kappa(\theta) = \gamma(1- \cos(\theta))\frac{(n-1)(m-1)}{(n-m)h_{\text{min}}}.$</span></p><p>For <span>$f(h)$</span> one can use various forms, a very common however is the power law given by </p><p><span>$f(h) = \bigg[\bigg(\frac{h_{\text{min}}}{h}\bigg)^n - \bigg(\frac{h_{\text{min}}}{h}\bigg)^m\bigg].$</span></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Swalbe, Test

julia&gt; h = reshape(collect(1.0:25.0),5,5) # A dummy height field
5×5 Array{Float64,2}:
 1.0   6.0  11.0  16.0  21.0
 2.0   7.0  12.0  17.0  22.0
 3.0   8.0  13.0  18.0  23.0
 4.0   9.0  14.0  19.0  24.0
 5.0  10.0  15.0  20.0  25.0

julia&gt; pressure = zeros(5,5); θ = 0.0; # Fully wetting substrate

julia&gt; Swalbe.filmpressure!(pressure, h, θ) # default γ = 0.01

julia&gt; result = [30.0 5.0 5.0 5.0 -20;
                 25.0 0.0 0.0 0.0 -25.0;
                 25.0 0.0 0.0 0.0 -25.0;
                 25.0 0.0 0.0 0.0 -25.0;
                 20.0 -5.0 -5.0 -5.0 -30.0];

julia&gt; for i in eachindex(result)
           @test result[i] .≈ -100 .* pressure[i] atol=1e-12
       end</code></pre><p><strong>References</strong></p><ul><li><a href="https://www.pnas.org/content/116/19/9275">Peschka et al.</a></li><li><a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.81.1131">Craster and Matar</a></li><li><a href="https://www.sciencedirect.com/science/article/abs/pii/0021979778900565">Derjaguin and Churaev</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.moments!-NTuple{4,Any}" href="#Swalbe.moments!-NTuple{4,Any}"><code>Swalbe.moments!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">moments!(height, velx, vely, fout)</code></pre><p>Computation of the hydrodynamic moments, <code>height</code> and <code>velocity</code>.</p><p><strong>Mathematics</strong></p><p>The macroscopic quantities such as the height and the velocity are the moments of the distribution function, </p><p><span>$h(\mathbf{x},t) = \sum_{i=0}^8 f_i ,$</span></p><p>and </p><p><span>$\mathbf{v}(\mathbf{x},t) = \frac{1}{h}\sum_{i=0}^8 \mathbf{c}_i f_i .$</span></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Swalbe, Test

julia&gt; fout = zeros(5,5,9); fout[:,:,1] .= 1.0; fout[:,:,2] .= 0.1; # Dist with artifical velocity in x

julia&gt; height = zeros(5,5); velx = zeros(5,5); vely = zeros(5,5);

julia&gt; Swalbe.moments!(height,velx,vely,fout)

julia&gt; @test all(height .== 1.1)
Test Passed

julia&gt; @test all(velx .== 0.1/1.1)
Test Passed

julia&gt; @test all(vely .== 0.0)
Test Passed</code></pre><p><strong>References</strong></p><ul><li><a href="https://www.springer.com/gp/book/9783319446479">Krüger</a></li><li><a href="https://www.ingentaconnect.com/contentone/jmr/jmr/1999/00000057/00000003/art00005#">Salmon</a></li><li><a href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.100.033313">Zitz, Scagliarini and Harting</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.power_broad-Tuple{Float64,Int64}" href="#Swalbe.power_broad-Tuple{Float64,Int64}"><code>Swalbe.power_broad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">power_broad(arg, n)</code></pre><p>Computes <code>arg</code> to the power <code>n</code>.</p><p>Actually this is useful because the <code>^</code> operator is much slower. Same thing I learned about the <code>pow</code> function in <strong>C</strong>, * yes it does what you want, but it is slow as fuck *.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Swalbe, Test

julia&gt; Swalbe.power_broad(3, 3)
27

julia&gt; Swalbe.power_broad.([2.0 5.0 6.0], 2) # Use the broadcasting operator `.`
1×3 Array{Float64,2}:
 4.0  25.0  36.0
</code></pre><p>See also: <a href="@ref"><code>filmpressure</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.randinterface!-Tuple{Any,Any,Any}" href="#Swalbe.randinterface!-Tuple{Any,Any,Any}"><code>Swalbe.randinterface!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randinterface!(height, h₀, ϵ)</code></pre><p>Creates a random height field with average height <code>h₀</code> and displacement magnitude <code>ϵ</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.run_dropletforced-Tuple{Swalbe.SysConst,String}" href="#Swalbe.run_dropletforced-Tuple{Swalbe.SysConst,String}"><code>Swalbe.run_dropletforced</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">run_dropletforced()</code></pre><p>Simulates an droplet on a patterned substrate</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.run_dropletpatterned-Tuple{Swalbe.SysConst,String}" href="#Swalbe.run_dropletpatterned-Tuple{Swalbe.SysConst,String}"><code>Swalbe.run_dropletpatterned</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">run_dropletpatterned()</code></pre><p>Simulates an droplet on a patterned substrate</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.run_dropletrelax-Tuple{Swalbe.SysConst,String}" href="#Swalbe.run_dropletrelax-Tuple{Swalbe.SysConst,String}"><code>Swalbe.run_dropletrelax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">run_dropletrelax()</code></pre><p>Simulates an out of equilibrium droplet</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.run_flat-Tuple{Swalbe.SysConst,String}" href="#Swalbe.run_flat-Tuple{Swalbe.SysConst,String}"><code>Swalbe.run_flat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">run_flat(Sys::SysConst, device::String)</code></pre><p>Performs a simulation of an flat interface without forces</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.run_random-Tuple{Swalbe.SysConst,String}" href="#Swalbe.run_random-Tuple{Swalbe.SysConst,String}"><code>Swalbe.run_random</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">run_random(sys::SysConst, device::String)</code></pre><p>Simulation of an random undulated interface</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.run_rayleightaylor-Tuple{Swalbe.SysConst,String}" href="#Swalbe.run_rayleightaylor-Tuple{Swalbe.SysConst,String}"><code>Swalbe.run_rayleightaylor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">run_rayleightaylor(sys::SysConst, device::String)</code></pre><p>Simulation of an random undulated interface</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.sinewave1D!-Tuple{Any,Any,Int64,Any,Int64}" href="#Swalbe.sinewave1D!-Tuple{Any,Any,Int64,Any,Int64}"><code>Swalbe.sinewave1D!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sinewave1D!(height, h₀, n, ϵ)</code></pre><p>Creates a sine wave like height field with <code>n</code> full waves, average height <code>h₀</code> and displacement magnitude <code>ϵ</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.singledroplet-NTuple{4,Any}" href="#Swalbe.singledroplet-NTuple{4,Any}"><code>Swalbe.singledroplet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">singledroplet(T, size(θ,1), size(θ,2), radius, θ, center, device=false)</code></pre><p>Generates a fluid configuration of a single droplet in the shape of spherical cap with contact angle <code>θ</code>, sphere radius <code>radius</code> and centered at <code>center</code>.</p><p><strong>Arguments</strong></p><ul><li><code>height::Array{undef, 2}</code>: numerical formate, either <code>Float64</code> or <code>Float32</code></li><li><code>radius::AbstractFloat</code>: radius of the underlying sphere from which the spherical cap is cut off</li><li><code>θ::AbstractFloat</code>: contact angle in multiples of <code>π</code></li><li><code>center::Tuple{Int,Int}</code>: x and y coordinates of the center of the droplet</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Swalbe, Test

julia&gt; rad = 50; θ = 1/3;

julia&gt; height = Swalbe.singledroplet(ones(100,100), rad, θ, (50,50));

julia&gt; @test maximum(height) == rad * (1 - cospi(θ)) # Simple geometry
Test Passed

julia&gt; argmax(height) # Which is constistent with the center!
CartesianIndex(50, 50)
</code></pre><p><strong>References</strong></p><p>See also: </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.slippage!-NTuple{7,Any}" href="#Swalbe.slippage!-NTuple{7,Any}"><code>Swalbe.slippage!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">slippage!(slipx, slipy, height, velx, vely, δ, μ)</code></pre><p>Fluid substrate interaction that effectively mimics a velocity boundary condition at <span>$h=0$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>slipx :: Array{&lt;:Number,2}</code>: The x-component of the force due the velocity boundary condition</li><li><code>slipy :: Array{&lt;:Number,2}</code>: The y-component of the force due the velocity boundary condition</li><li><code>height::Array{&lt;:Number,2}</code>: Height field <span>$h(\mathbf{x},t)$</span></li><li><code>velx::Array{&lt;:Number,2}</code>: x-component of the macroscopic velocity vector</li><li><code>vely::Array{&lt;:Number,2}</code>: y-component of the macroscopic velocity vector</li><li><code>δ &lt;: Number</code>: Extrapolation length into the substrate where the <strong>no-slip</strong> is met</li><li><code>μ &lt;: Number</code>: Kinematic viscosity of the simulation, dependent on the value of <strong>τ</strong></li></ul><p><strong>Mathematics</strong></p><p>With the velocity boundary condition at the fluid substrate interface we build the second main descriptor between our model and the thin film equation. One well studied assumption is that the fluid velocity vanishes at <span>$h(\mathbf{x}) = 0$</span> which is called <strong>no slip</strong> condition.</p><p>TBD</p><p><strong>Examples</strong></p><p>TBD</p><p><strong>References</strong></p><ul><li><a href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.100.033313">Zitz, Scagliarini and Harting</a></li><li><a href="https://link.springer.com/article/10.1007/s10665-005-9020-3">Münch, Wagner und Witelski</a></li><li><a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.69.931">Oron, Davis and Bankoff</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.thermal!-NTuple{6,Any}" href="#Swalbe.thermal!-NTuple{6,Any}"><code>Swalbe.thermal!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">thermal!(fx, fy, height, kᵦT, μ, δ)</code></pre><p>Computations of force due to thermal fluctuations.</p><p><strong>Arguments</strong></p><ul><li><code>fx :: Array{&lt;:Number,2}</code>: x-component of the force due to the fluctuations</li><li><code>fy :: Array{&lt;:Number,2}</code>: y-component of the force due to the fluctuations</li><li><code>height :: Array{&lt;:Number,2}</code>: Height field <span>$h(\mathbf{x},t)$</span></li><li><code>kᵦT &lt;: Number</code>: Strenght of thermal fluctuations in lattice units</li><li><code>μ &lt;: Number</code>: The kinetic viscosity</li><li><code>δ &lt;: Number</code>: Slip length, needed to normalize</li></ul><p><strong>Mathematics</strong></p><p>TBD</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Swalbe, Statistics, Test

julia&gt; x = ones(50,50); y = ones(50,50); h = ones(50,50);

julia&gt; Swalbe.thermal!(x, y, h, 0.1, 1/6, 1)

julia&gt; @test mean(x) ≈ 0.0 atol=1e-2
Test Passed

julia&gt; @test mean(y) ≈ 0.0 atol=1e-2
Test Passed

julia&gt; @test var(x) ≈ 2*0.1/11 atol=(2*0.1/11)/10 # var = 2kbt*6*μ/slip
Test Passed
</code></pre><p><strong>References</strong></p><ul><li><a href="https://link.springer.com/article/10.1007/s10955-006-9028-8">Grün, Mecke and Rauscher</a></li><li><a href="https://iopscience.iop.org/article/10.1088/0953-8984/17/45/042/meta">Mecke, Rauscher</a></li><li><a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.95.244505">Davidovitch, Moro and Stone</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.trianglepattern-Tuple{Any,Any}" href="#Swalbe.trianglepattern-Tuple{Any,Any}"><code>Swalbe.trianglepattern</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trianglepattern(θ, θ₀; center=(size(θ,1)÷2, size(θ,2)÷2), δₐ=1/36, side=60)</code></pre><p>Generates an equilateral triangle centered around <code>center</code> with contact angle contrast <code>δₐ</code> and side length <code>side</code>.</p><p><strong>Arguments</strong></p><ul><li><code>θ::Array{undef,2}</code>: Contact angle map</li><li><code>θ₀</code>: Default contact angle <code>θ</code></li><li><code>center::Tuple(Int, Int)</code>: position of the center of the triangle</li><li><code>δₐ::Float64</code>: contact angle contrast with the rest of the substrate</li><li><code>side::Int</code>: length of the sides of the equilateral triangle</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Swalbe

julia&gt; θ, P = Swalbe.trianglepattern(ones(50,50), 1/9, side=20) # Returns a polygon and the contact angle field
([0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111; 0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111; … ; 0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111; 0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111], LazySets.VPolygon{Float64,Array{Float64,1}}([[15.0, 19.226497308103742], [35.0, 19.226497308103742], [25.0, 36.547005383792516]]))

julia&gt; P
LazySets.VPolygon{Float64,Array{Float64,1}}([[15.0, 19.226497308103742], [35.0, 19.226497308103742], [25.0, 36.547005383792516]])

julia&gt; θ[25,25]
0.1388888888888889</code></pre><p><strong>References</strong></p><p>See also:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.viewdists-Tuple{Any}" href="#Swalbe.viewdists-Tuple{Any}"><code>Swalbe.viewdists</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">viewdists(f)</code></pre><p>Generates a view for all nine populations of a <strong>D2Q9</strong> distribution function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Swalbe, Test

julia&gt; ftest = reshape(collect(1.0:225.0),5,5,9);

julia&gt; f0, f1, f2, f3, f4, f5, f6, f7, f8 = Swalbe.viewdists(ftest);

julia&gt; @test all(f3 .== ftest[:,:,4])
Test Passed
</code></pre><p>See also: <a href="@ref"><code>Swalbe.BGKandStream</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.viewneighbors-Tuple{Any}" href="#Swalbe.viewneighbors-Tuple{Any}"><code>Swalbe.viewneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">viewneighbors(f)</code></pre><p>Generates a view for all nine populations of a <strong>D2Q9</strong> distribution function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Swalbe, Test

julia&gt; ftest = reshape(collect(1.0:5*5*8),5,5,8);

julia&gt; f1, f2, f3, f4, f5, f6, f7, f8 = Swalbe.viewneighbors(ftest);

julia&gt; @test all(f3 .== ftest[:,:,3])
Test Passed
</code></pre><p>See also: <a href="#Swalbe.∇f!-Tuple{Any,Any,Any}"><code>Swalbe.∇f!</code></a>, <a href="#Swalbe.filmpressure!-NTuple{8,Any}"><code>Swalbe.filmpressure!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.∇f!-Tuple{Any,Any,Any}" href="#Swalbe.∇f!-Tuple{Any,Any,Any}"><code>Swalbe.∇f!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∇f!(outputx, outputy, f)</code></pre><p>Gradient calculation with finite differences.</p><p>Computes both spatial first derivatives with a nine point stencil from an input <code>f</code> and writes the result to <code>outputx</code> and <code>outputy</code>. Since broadcasting is simple on the <strong>GPU</strong> we make use of <code>circshift</code> for the neighbors.</p><p><strong>Mathematics</strong></p><p>The gardient in two dimensions is given as</p><p><span>$\nabla f = \big(\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}\big)^T .$</span></p><p>Again with the nine point stencil this reduces to </p><p><span>$\frac{\partial f}{\partial x} = \frac{1}{3} (f_{i+1,j} - f_{i-1,j}) + \frac{1}{12}(f_{i+1,j+1} - f_{i-1,j+1} - f_{i-1,j-1} + f_{i+1,j-1}) ,$</span></p><p>and for the <code>y</code> component we get</p><p><span>$\frac{\partial f}{\partial y} = \frac{1}{3} (f_{i,j+1} - f_{i,j-1}) + \frac{1}{12}(f_{i+1,j+1} + f_{i-1,j+1} - f_{i-1,j-1} - f_{i+1,j-1}) .$</span></p><p>For the exact derivation feel free to read the reference by Junk and Klar.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Swalbe, Test

julia&gt; arg = reshape(collect(1.0:25),5,5)
5×5 Array{Float64,2}:
 1.0   6.0  11.0  16.0  21.0
 2.0   7.0  12.0  17.0  22.0
 3.0   8.0  13.0  18.0  23.0
 4.0   9.0  14.0  19.0  24.0
 5.0  10.0  15.0  20.0  25.0

julia&gt; resx = zeros(5,5); resy = zeros(5,5); Swalbe.∇f!(resx, resy, arg)

julia&gt; whatXshouldbe = [-1.5 -1.5 -1.5 -1.5 -1.5;
                         1.0 1.0 1.0 1.0 1.0;
                         1.0 1.0 1.0 1.0 1.0;
                         1.0 1.0 1.0 1.0 1.0;
                        -1.5 -1.5 -1.5 -1.5 -1.5];

julia&gt; for i in eachindex(resx) # Test the x-component
           @test resx[i] ≈ whatXshouldbe[i] atol=1e-10
       end

julia&gt; whatYshouldbe = [-7.5 5.0 5.0 5.0 -7.5;
                        -7.5 5.0 5.0 5.0 -7.5;
                        -7.5 5.0 5.0 5.0 -7.5;
                        -7.5 5.0 5.0 5.0 -7.5;
                        -7.5 5.0 5.0 5.0 -7.5];

julia&gt; for i in eachindex(resy) # Test the y-component
           @test resy[i] ≈ whatYshouldbe[i] atol=1e-10
       end</code></pre><p><strong>References</strong></p><ul><li><a href="https://epubs.siam.org/doi/10.1137/S1064827599357188">Junk &amp; Klar</a></li><li><a href="https://doi.org/10.1016/j.jcp.2012.07.037">Succi et al.</a></li></ul><p>See also: <a href="#Swalbe.∇²f!-Tuple{Any,Any,Any}"><code>Swalbe.∇²f!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Swalbe.∇²f!-Tuple{Any,Any,Any}" href="#Swalbe.∇²f!-Tuple{Any,Any,Any}"><code>Swalbe.∇²f!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∇²f!(output, f, γ)</code></pre><p>Finite difference operator for a second derivative in two dimensions.</p><p>Computes the laplacian of an input <code>f</code> times a scalar <code>γ</code> and stores the result in <code>output</code>.</p><p><strong>Mathematics</strong></p><p>The laplacian operator in two dimensions can be written as</p><p><span>$\nabla^2 f = \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y}.$</span></p><p>For the discretization of this operator we use a nine point stencil, such the neighbors as well as the diagonal elements. The concrete derivation can be found in the references below, we just show the final result</p><p><span>$\nabla^2 f = \frac{1}{6}\bigg[4(f_{i+1,j} + f_{i,j+1} + f_{i-1,j} + f_{i,j-1}) \newline                 \qquad\qquad +(f_{i+1,j+1} + f_{i-1,j+1} + f_{i-1,j-1} + f_{i+1,j-1}) \newline                 \qquad\qquad -20f_{i,j}\bigg]  ,$</span></p><p>where we have used Julia conventions, downwards (left) is positive.  The whole expression can be multiplied with a scalar <code>γ</code> if needed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Swalbe, Test

julia&gt; arg = reshape(collect(1.0:25),5,5)
5×5 Array{Float64,2}:
 1.0   6.0  11.0  16.0  21.0
 2.0   7.0  12.0  17.0  22.0
 3.0   8.0  13.0  18.0  23.0
 4.0   9.0  14.0  19.0  24.0
 5.0  10.0  15.0  20.0  25.0

julia&gt; res = zeros(5,5); Swalbe.∇²f!(res, arg, -1.0)

julia&gt; analytics = [-30.0 -5.0 -5.0 -5.0 20;
                    -25.0 0.0 0.0 0.0 25.0;
                    -25.0 0.0 0.0 0.0 25.0;
                    -25.0 0.0 0.0 0.0 25.0;
                    -20.0 5.0 5.0 5.0 30.0];

julia&gt; for i in eachindex(analytics)
           @test analytics[i] ≈ res[i] atol=1e-10
       end</code></pre><p><strong>References</strong></p><ul><li><a href="https://epubs.siam.org/doi/10.1137/S1064827599357188">Junk &amp; Klar</a></li><li><a href="https://doi.org/10.1016/j.jcp.2012.07.037">Succi et al.</a></li></ul><p>See also: <a href="#Swalbe.∇f!-Tuple{Any,Any,Any}"><code>Swalbe.∇f!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 14 December 2020 16:23">Monday 14 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
