var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Swalbe","category":"page"},{"location":"#Swalbe","page":"Home","title":"Swalbe","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Swalbe]","category":"page"},{"location":"#Swalbe.SysConst","page":"Home","title":"Swalbe.SysConst","text":"SysConst{T}\n\nStruct that contains all run time constants, e.g. lattice size, surface tension γ and so on.\n\n\n\n\n\n","category":"type"},{"location":"#Swalbe.BGKandStream!-NTuple{6,Any}","page":"Home","title":"Swalbe.BGKandStream!","text":"BGKandStream!(fout, feq, ftemp, Fx, Fy, τ)\n\nPerforms a BGK collision operation with a WFM forcecorrection and a subsequent streaming of the resulting populations.\n\nArguments\n\nfout :: Array{<:Number,3}: Streamed distribution after the collision processes\nfeq :: Array{<:Number,3}: Equilibrium distribution, computed with equilibrium!\nftemp :: Array{<:Number,3}: Temporary distribution from the time step before, only useful if tau neq 1\nFx :: Array{<:Number,2}: Sum of forces acting on the fluid in x-direction\nFy :: Array{<:Number,2}: Sum of forces acting on the fluid in y-direction\nτ <: Number: Relaxtion time, if not supplied tau = 1 assumed\n\nMathematics\n\nThe lattice Boltzmann equation in its discretized format is relatively simple to write down\n\nf_alpha(mathbfx+mathbfe_alphaDelta t t+Delta t) - f_alpha(mathbfx t) = -frac1tau(f_alpha(mathbfx t) - f^texteq_alpha(mathbfx t)) + Delta t mathcalS_alpha\n\nwhere the collision kernel is approximated with a BKG single relaxation time (SRT) \n\nOmega_alpha = frac1tau(f_alpha(mathbfx t) - f^texteq_alpha(mathbfx t)\n\nand a source term mathcalS which is given by\n\nmathcalS_alpha = frac3 w_alphae_alpha xe_alpha x+e_alpha ye_alpha ymathbfe_alphacdotmathbfF_alpha \n\nThe term e_alpha xe_alpha x+e_alpha ye_alpha y is either zero for the zeroth population, 1 for the first four populations or 2 for the remaining ones.\n\nExamples\n\njulia> using Swalbe\n\njulia> feq = ones(5,5,9); ftemp = zeros(5,5,9); fout = zeros(5,5,9);\n\njulia> feq[1,1,:] .= 2.0 # To check the streaming process \n9-element view(::Array{Float64,3}, 1, 1, :) with eltype Float64:\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n\njulia> Swalbe.BGKandStream!(fout, feq, ftemp, zeros(5,5), zeros(5,5))\n\njulia> fout[:,:,6] # The value 2 should have moved one down and one to the right!\n5×5 Array{Float64,2}:\n 1.0  1.0  1.0  1.0  1.0\n 1.0  2.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n\n\nReferences\n\nSalmon\nDellar\nPeng et al.\n\nSee also: Swalbe.equilibrium\n\n\n\n\n\n","category":"method"},{"location":"#Swalbe.Sys-Tuple{Swalbe.SysConst,String,Bool}","page":"Home","title":"Swalbe.Sys","text":"Sys(sysc, device, exotic)\n\nMostly allocations of arrays used to run a simulation, but all within one function :)\n\n\n\n\n\n","category":"method"},{"location":"#Swalbe.boxpattern-Tuple{Any,Any}","page":"Home","title":"Swalbe.boxpattern","text":"boxpattern(θ, θ₀; center=(size(θ,1)÷2, size(θ,2)÷2), δₐ=1/36, side=20)\n\nDefines a quadratic box around a center with side length side.\n\nArguments\n\nθ::Array{undef,2}: Contact angle map\nθ₀: Default contact angle θ\ncenter::Tuple{Int, Int}: center of the box pattern, default value is (size(θ,1)÷2, size(θ,2)÷2)\nδₐ::Float64: Contact angle contrast with the substrate, default is set to 1/36 ≈ 5 degrees difference\nside::Int: Length of the sides, default is set to 20\n\nExamples\n\njulia> using Swalbe\n\njulia> θ₀ = 1/9;\n\njulia> pattern, polygon = Swalbe.boxpattern(ones(100,100), θ₀);\n\njulia> polygon # Some cool thing we use to create the posize(θ,2)gones, a LazySet\nLazySets.VPolygon{Float64,Array{Float64,1}}([[40.0, 40.0], [60.0, 40.0], [60.0, 60.0], [40.0, 60.0]])\n\njulia> pattern[50,50] == pattern[1,1] # In the center there is a different contact angle!\nfalse\n\n\nReferences\n\nRealsize(θ,2) not much to say here, check out LazySets.jl.\n\n\n\n\n\n","category":"method"},{"location":"#Swalbe.ellipsepattern-Tuple{Any,Any}","page":"Home","title":"Swalbe.ellipsepattern","text":"ellipsepattern(θ, θ₀; center=(size(θ,1)÷2, size(θ,2)÷2), δₐ=1/36, a=10, b=5)\n\nCreates an ellipse shaped contact angle defect with contact angle mismatch δₐ.\n\nArguments\n\nθ::Array{undef,2}: Contact angle map\nθ₀: Default contact angle θ\ncenter::Tuple{Int, Int}: center of the created pattern, default values is center = (size(θ,1)÷2, size(θ,2)÷2)\nδₐ::Float64: contact angle mismatch between patch and rest of substrate, default is δₐ = 1/36 or 5 degrees\na::Int:: semimajor half ax of the ellipse, default value is a=10\nb::Int:: semiminor half ax of the ellipse, default value is b=5\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> θ₀ = 1/9;\n\njulia> θ, P = Swalbe.ellipsepattern(ones(100,100), θ₀); # per default the center is in the middle!\n\njulia> @test θ[1,1] == θ₀\nTest Passed\n\njulia> @test θ[50,50] == θ₀ + 1/36 # The default increment, is about 5 degrees.\nTest Passed\n\n\nReferences\n\nNothing interesting here.\n\n\n\n\n\n","category":"method"},{"location":"#Swalbe.equilibrium!-NTuple{6,Any}","page":"Home","title":"Swalbe.equilibrium!","text":"Equilibrium!(feq, height,velocityx, velocityy, vsquare, gravity)\n\nCalculation of the equilibrium distribution feq for the shallow water lattice Boltzmann method.\n\nArguments\n\nfeq :: Array{<:Number,3}: Equilibrium distribution function, to be calculated\nheight :: Array{<:Number,2}: The height field h(mathbfxt)\nvelocityx :: Array{<:Number,2}: x-component of the macroscopic velocity\nvelocityy :: Array{<:Number,2}: y-component of the macroscopic velocity\nvsquare :: Array{<:Number,2}: Dummy array that is preallocated to be filled with the square of the velocity vector\ngravity <: Number: Strength of the gravitational acceleration in lattice units\n\nMathematics\n\nThe detailed motivation and derivation can be found in the article of Salmon. Similar to the standard Navier-Stokes approximating lattice Boltzmann methods the equilibrium distribution feq is an expansion to second order in velocity u. If you want it is an slow mode part of the shallow water theory and thus the equilibrium is given as\n\nf_i^texteq = h bigg(1 - frac56g h - frac23u^2bigg)quad i=0 newline    f_i^texteq = w_i h bigg(g h + 3 mathbfc_icdotmathbfu + frac92(mathbfc_icdotmathbfu)^2) + frac32u^2bigg)quad else\n\nwhere g is the gravitational acceleration (in lattice units) and w_i mathbfc_i are the weights and lattice velocities.\n\nIt has been shown that it is possible to get rid of the gravity driven term in the equilibrium distribution, thus\n\nf_i^texteq = h bigg(1 - frac23u^2bigg)quad i=0 newline f_i^texteq = w_i h bigg(3 mathbfc_icdotmathbfu + frac92(mathbfc_icdotmathbfu)^2) + frac32u^2bigg)quad else\n\nthen of course the topography gradient has to be included as a force term.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> feq = zeros(5,5,9); ρ = ones(5,5); ux = fill(0.1,5,5); uy = zeros(5,5);\n\njulia> Swalbe.equilibrium!(feq, ρ, ux, uy, zeros(5,5), 0.1) # Supply dummy u^2 as well.\n\njulia> feq[:,:,1]\n5×5 Array{Float64,2}:\n 0.91  0.91  0.91  0.91  0.91\n 0.91  0.91  0.91  0.91  0.91\n 0.91  0.91  0.91  0.91  0.91\n 0.91  0.91  0.91  0.91  0.91\n 0.91  0.91  0.91  0.91  0.91\n\njulia> Swalbe.equilibrium!(feq, ρ, ux, uy, zeros(5,5)) # Use the dispatch without g.\n\njulia> @test all(feq[:,:,1] .≈ 1 - 2/3 * 0.01)\nTest Passed\n\nReferences\n\nSalmon\nDellar\nPeng et al.\n\n\n\n\n\n","category":"method"},{"location":"#Swalbe.filmpressure!-NTuple{8,Any}","page":"Home","title":"Swalbe.filmpressure!","text":"filmpressure!(pressure, height, γ, θ, n, m, hmin, hcrit)\n\nCalculation of the capillary pressure which is given by p = - γ²h+ Π(h).\n\nArguments\n\npressure :: Array{Number,2}: Array that store the result of the compuation\nheight :: Array{Number,2}: Height field h(mathbfxt)\nγ <: Number: Forcing strenght due to surface tension\nθ <: Number: Equilibrium contact angle\nn :: Int: Larger power law exponent for Π(h)\nm :: Int: Smaller power law exponent for Π(h)\nhmin <: Number: Parameter of Π(h), in fact Π(hmin) = 0\nhcrit <: Number: Numerical stabilizer for case h(mathbfxt) ll hmin\n\nMathematics\n\nThe capillary pressure p_textcap is the centeral angle to match our model with the thin film equation. It consists of two parts, first being the laplace pressure nabla^2 h and second being the derivative of the disjoining pontential Pi(h)\n\np_textcap = -gamma nabla^2 h + Pi(h)\n\nFor the laplacian term we use the same nine point discretization as in Swlabe.∇²f!. Pi(h) on the other hand is given by \n\nPi(h) = kappa(theta)f(h)\n\nwhere kappa(theta) is simply a measure for the Hamaker constant and given as\n\nkappa(theta) = gamma(1- cos(theta))frac(n-1)(m-1)(n-m)h_textmin\n\nFor f(h) one can use various forms, a very common however is the power law given by \n\nf(h) = biggbigg(frach_textminhbigg)^n - bigg(frach_textminhbigg)^mbigg\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> h = reshape(collect(1.0:25.0),5,5) # A dummy height field\n5×5 Array{Float64,2}:\n 1.0   6.0  11.0  16.0  21.0\n 2.0   7.0  12.0  17.0  22.0\n 3.0   8.0  13.0  18.0  23.0\n 4.0   9.0  14.0  19.0  24.0\n 5.0  10.0  15.0  20.0  25.0\n\njulia> pressure = zeros(5,5); θ = 0.0; # Fully wetting substrate\n\njulia> Swalbe.filmpressure!(pressure, h, θ) # default γ = 0.01\n\njulia> result = [30.0 5.0 5.0 5.0 -20;\n                 25.0 0.0 0.0 0.0 -25.0;\n                 25.0 0.0 0.0 0.0 -25.0;\n                 25.0 0.0 0.0 0.0 -25.0;\n                 20.0 -5.0 -5.0 -5.0 -30.0];\n\njulia> for i in eachindex(result)\n           @test result[i] .≈ -100 .* pressure[i] atol=1e-12\n       end\n\nReferences\n\nPeschka et al.\nCraster and Matar\nDerjaguin and Churaev\n\n\n\n\n\n","category":"method"},{"location":"#Swalbe.moments!-NTuple{4,Any}","page":"Home","title":"Swalbe.moments!","text":"moments!(height, velx, vely, fout)\n\nComputation of the hydrodynamic moments, height and velocity.\n\nMathematics\n\nThe macroscopic quantities such as the height and the velocity are the moments of the distribution function, \n\nh(mathbfxt) = sum_i=0^8 f_i \n\nand \n\nmathbfv(mathbfxt) = frac1hsum_i=0^8 mathbfc_i f_i \n\nExamples\n\njulia> using Swalbe, Test\n\njulia> fout = zeros(5,5,9); fout[:,:,1] .= 1.0; fout[:,:,2] .= 0.1; # Dist with artifical velocity in x\n\njulia> height = zeros(5,5); velx = zeros(5,5); vely = zeros(5,5);\n\njulia> Swalbe.moments!(height,velx,vely,fout)\n\njulia> @test all(height .== 1.1)\nTest Passed\n\njulia> @test all(velx .== 0.1/1.1)\nTest Passed\n\njulia> @test all(vely .== 0.0)\nTest Passed\n\nReferences\n\nKrüger\nSalmon\nZitz, Scagliarini and Harting\n\n\n\n\n\n","category":"method"},{"location":"#Swalbe.power_broad-Tuple{Float64,Int64}","page":"Home","title":"Swalbe.power_broad","text":"power_broad(arg, n)\n\nComputes arg to the power n.\n\nActually this is useful because the ^ operator is much slower. Same thing I learned about the pow function in C, * yes it does what you want, but it is slow as fuck *.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> Swalbe.power_broad(3, 3)\n27\n\njulia> Swalbe.power_broad.([2.0 5.0 6.0], 2) # Use the broadcasting operator `.`\n1×3 Array{Float64,2}:\n 4.0  25.0  36.0\n\n\nSee also: filmpressure\n\n\n\n\n\n","category":"method"},{"location":"#Swalbe.randinterface!-Tuple{Any,Any,Any}","page":"Home","title":"Swalbe.randinterface!","text":"randinterface!(height, h₀, ϵ)\n\nCreates a random height field with average height h₀ and displacement magnitude ϵ.  \n\n\n\n\n\n","category":"method"},{"location":"#Swalbe.run_flat-Tuple{Swalbe.SysConst,String}","page":"Home","title":"Swalbe.run_flat","text":"run_flat(Sys::SysConst, device::String)\n\nPerforms a simulation of an flat interface without forces\n\n\n\n\n\n","category":"method"},{"location":"#Swalbe.run_random-Tuple{Swalbe.SysConst,String}","page":"Home","title":"Swalbe.run_random","text":"run_random(sys::SysConst, device::String)\n\nSimulation of an random undulated interface\n\n\n\n\n\n","category":"method"},{"location":"#Swalbe.sinewave1D!-Tuple{Any,Any,Int64,Any,Int64}","page":"Home","title":"Swalbe.sinewave1D!","text":"sinewave1D!(height, h₀, n, ϵ)\n\nCreates a sine wave like height field with n full waves, average height h₀ and displacement magnitude ϵ.  \n\n\n\n\n\n","category":"method"},{"location":"#Swalbe.singledroplet-NTuple{4,Any}","page":"Home","title":"Swalbe.singledroplet","text":"singledroplet(T, size(θ,1), size(θ,2), radius, θ, center, device=false)\n\nGenerates a fluid configuration of a single droplet in the shape of spherical cap with contact angle θ, sphere radius radius and centered at center.\n\nArguments\n\nheight::Array{undef, 2}: numerical formate, either Float64 or Float32\nradius::AbstractFloat: radius of the undersize(θ,2)ing sphere from which the spherical cap is cut off\nθ::AbstractFloat: contact angle in multiples of π\ncenter::Tuple{Int,Int}: x and y coordinates of the center of the droplet\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> rad = 50; θ = 1/3;\n\njulia> height = Swalbe.singledroplet(ones(100,100), rad, θ, (50,50));\n\njulia> @test maximum(height) == rad * (1 - cospi(θ)) # Simple geometry\nTest Passed\n\njulia> argmax(height) # Which is constistent with the center!\nCartesianIndex(50, 50)\n\n\nReferences\n\nSee also: \n\n\n\n\n\n","category":"method"},{"location":"#Swalbe.slippage!-NTuple{7,Any}","page":"Home","title":"Swalbe.slippage!","text":"slippage!(slipx, slipy, height, velx, vely, δ, μ)\n\nFluid substrate interaction that effectively mimics a velocity boundary condition at h=0.\n\nArguments\n\nslipx :: Array{<:Number,2}: The x-component of the force due the velocity boundary condition\nslipy :: Array{<:Number,2}: The y-component of the force due the velocity boundary condition\nheight::Array{<:Number,2}: Height field h(mathbfxt)\nvelx::Array{<:Number,2}: x-component of the macroscopic velocity vector\nvely::Array{<:Number,2}: y-component of the macroscopic velocity vector\nδ <: Number: Extrapolation length into the substrate where the no-slip is met\nμ <: Number: Kinematic viscosity of the simulation, dependent on the value of τ\n\nMathematics\n\nWith the velocity boundary condition at the fluid substrate interface we build the second main descriptor between our model and the thin film equation. One well studied assumption is that the fluid velocity vanishes at h(mathbfx) = 0 which is called no slip condition.\n\nTBD\n\nExamples\n\nTBD\n\nReferences\n\nZitz, Scagliarini and Harting\nMünch, Wagner und Witelski\nOron, Davis and Bankoff\n\n\n\n\n\n","category":"method"},{"location":"#Swalbe.thermal!-NTuple{6,Any}","page":"Home","title":"Swalbe.thermal!","text":"thermal!(fx, fy, height, kᵦT, μ, δ)\n\nComputations of force due to thermal fluctuations.\n\nArguments\n\nfx :: Array{<:Number,2}: x-component of the force due to the fluctuations\nfy :: Array{<:Number,2}: y-component of the force due to the fluctuations\nheight :: Array{<:Number,2}: Height field h(mathbfxt)\nkᵦT <: Number: Strenght of thermal fluctuations in lattice units\nμ <: Number: The kinetic viscosity\nδ <: Number: Slip length, needed to normalize\n\nMathematics\n\nTBD\n\nExamples\n\njulia> using Swalbe, Statistics, Test\n\njulia> x = ones(50,50); y = ones(50,50); h = ones(50,50);\n\njulia> Swalbe.thermal!(x, y, h, 0.1, 1/6, 1)\n\njulia> @test mean(x) ≈ 0.0 atol=1e-2\nTest Passed\n\njulia> @test mean(y) ≈ 0.0 atol=1e-2\nTest Passed\n\njulia> @test var(x) ≈ 2*0.1/11 atol=(2*0.1/11)/10 # var = 2kbt*6*μ/slip\nTest Passed\n\n\nReferences\n\nGrün, Mecke and Rauscher\nMecke, Rauscher\nDavidovitch, Moro and Stone\n\n\n\n\n\n","category":"method"},{"location":"#Swalbe.trianglepattern-Tuple{Any,Any}","page":"Home","title":"Swalbe.trianglepattern","text":"trianglepattern(θ, θ₀; center=(size(θ,1)÷2, size(θ,2)÷2), δₐ=1/36, side=60)\n\nGenerates an equilateral triangle centered around center with contact angle contrast δₐ and side length side.\n\nArguments\n\nθ::Array{undef,2}: Contact angle map\nθ₀: Default contact angle θ\ncenter::Tuple(Int, Int): position of the center of the triangle\nδₐ::Float64: contact angle contrast with the rest of the substrate\nside::Int: length of the sides of the equilateral triangle\n\nExamples\n\njulia> using Swalbe\n\njulia> θ, P = Swalbe.trianglepattern(ones(50,50), 1/9, side=20) # Returns a polygon and the contact angle field\n([0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111; 0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111; … ; 0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111; 0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111], LazySets.VPolygon{Float64,Array{Float64,1}}([[15.0, 19.226497308103742], [35.0, 19.226497308103742], [25.0, 36.547005383792516]]))\n\njulia> P\nLazySets.VPolygon{Float64,Array{Float64,1}}([[15.0, 19.226497308103742], [35.0, 19.226497308103742], [25.0, 36.547005383792516]])\n\njulia> θ[25,25]\n0.1388888888888889\n\nReferences\n\nSee also:\n\n\n\n\n\n","category":"method"},{"location":"#Swalbe.viewdists-Tuple{Any}","page":"Home","title":"Swalbe.viewdists","text":"viewdists(f)\n\nGenerates a view for all nine populations of a D2Q9 distribution function.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> ftest = reshape(collect(1.0:225.0),5,5,9);\n\njulia> f0, f1, f2, f3, f4, f5, f6, f7, f8 = Swalbe.viewdists(ftest);\n\njulia> @test all(f3 .== ftest[:,:,4])\nTest Passed\n\n\nSee also: Swalbe.BGKandStream\n\n\n\n\n\n","category":"method"},{"location":"#Swalbe.∇f!-Tuple{Any,Any,Any}","page":"Home","title":"Swalbe.∇f!","text":"∇f!(outputx, outputy, f)\n\nGradient calculation with finite differences.\n\nComputes both spatial first derivatives with a nine point stencil from an input f and writes the result to outputx and outputy. Since broadcasting is simple on the GPU we make use of circshift for the neighbors.\n\nMathematics\n\nThe gardient in two dimensions is given as\n\nnabla f = big(fracpartial fpartial x fracpartial fpartial ybig)^T \n\nAgain with the nine point stencil this reduces to \n\nfracpartial fpartial x = frac13 (f_i+1j - f_i-1j) + frac112(f_i+1j+1 - f_i-1j+1 - f_i-1j-1 + f_i+1j-1) \n\nand for the y component we get\n\nfracpartial fpartial y = frac13 (f_ij+1 - f_ij-1) + frac112(f_i+1j+1 + f_i-1j+1 - f_i-1j-1 - f_i+1j-1) \n\nFor the exact derivation feel free to read the reference by Junk and Klar.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> arg = reshape(collect(1.0:25),5,5)\n5×5 Array{Float64,2}:\n 1.0   6.0  11.0  16.0  21.0\n 2.0   7.0  12.0  17.0  22.0\n 3.0   8.0  13.0  18.0  23.0\n 4.0   9.0  14.0  19.0  24.0\n 5.0  10.0  15.0  20.0  25.0\n\njulia> resx = zeros(5,5); resy = zeros(5,5); Swalbe.∇f!(resx, resy, arg)\n\njulia> whatXshouldbe = [-1.5 -1.5 -1.5 -1.5 -1.5;\n                         1.0 1.0 1.0 1.0 1.0;\n                         1.0 1.0 1.0 1.0 1.0;\n                         1.0 1.0 1.0 1.0 1.0;\n                        -1.5 -1.5 -1.5 -1.5 -1.5];\n\njulia> for i in eachindex(resx) # Test the x-component\n           @test resx[i] ≈ whatXshouldbe[i] atol=1e-10\n       end\n\njulia> whatYshouldbe = [-7.5 5.0 5.0 5.0 -7.5;\n                        -7.5 5.0 5.0 5.0 -7.5;\n                        -7.5 5.0 5.0 5.0 -7.5;\n                        -7.5 5.0 5.0 5.0 -7.5;\n                        -7.5 5.0 5.0 5.0 -7.5];\n\njulia> for i in eachindex(resy) # Test the y-component\n           @test resy[i] ≈ whatYshouldbe[i] atol=1e-10\n       end\n\nReferences\n\nJunk & Klar\nSucci et al.\n\nSee also: Swalbe.∇²f!\n\n\n\n\n\n","category":"method"},{"location":"#Swalbe.∇²f!-Tuple{Any,Any,Any}","page":"Home","title":"Swalbe.∇²f!","text":"∇²f!(output, f, γ)\n\nFinite difference operator for a second derivative in two dimensions.\n\nComputes the laplacian of an input f times a scalar γ and stores the result in output.\n\nMathematics\n\nThe laplacian operator in two dimensions can be written as\n\nnabla^2 f = fracpartial^2 fpartial x^2 + fracpartial^2 fpartial y\n\nFor the discretization of this operator we use a nine point stencil, such the neighbors as well as the diagonal elements. The concrete derivation can be found in the references below, we just show the final result\n\nnabla^2 f = frac16bigg4(f_i+1j + f_ij+1 + f_i-1j + f_ij-1) newline                 qquadqquad +(f_i+1j+1 + f_i-1j+1 + f_i-1j-1 + f_i+1j-1) newline                 qquadqquad -20f_ijbigg  \n\nwhere we have used Julia conventions, downwards (left) is positive.  The whole expression can be multiplied with a scalar γ if needed.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> arg = reshape(collect(1.0:25),5,5)\n5×5 Array{Float64,2}:\n 1.0   6.0  11.0  16.0  21.0\n 2.0   7.0  12.0  17.0  22.0\n 3.0   8.0  13.0  18.0  23.0\n 4.0   9.0  14.0  19.0  24.0\n 5.0  10.0  15.0  20.0  25.0\n\njulia> res = zeros(5,5); Swalbe.∇²f!(res, arg, -1.0)\n\njulia> analytics = [-30.0 -5.0 -5.0 -5.0 20;\n                    -25.0 0.0 0.0 0.0 25.0;\n                    -25.0 0.0 0.0 0.0 25.0;\n                    -25.0 0.0 0.0 0.0 25.0;\n                    -20.0 5.0 5.0 5.0 30.0];\n\njulia> for i in eachindex(analytics)\n           @test analytics[i] ≈ res[i] atol=1e-10\n       end\n\nReferences\n\nJunk & Klar\nSucci et al.\n\nSee also: Swalbe.∇f!\n\n\n\n\n\n","category":"method"}]
}
